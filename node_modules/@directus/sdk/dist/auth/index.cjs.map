{"version":3,"sources":["../../src/auth/index.ts","../../src/client.ts","../../src/utils/is-response.ts","../../src/utils/extract-data.ts","../../src/utils/request.ts","../../src/rest/utils/query-to-params.ts","../../src/utils/get-request-url.ts","../../src/auth/utils/memory-storage.ts","../../src/auth/composable.ts","../../src/auth/static.ts"],"sourcesContent":["export * from './composable.js';\nexport * from './static.js';\nexport * from './utils/memory-storage.js';\nexport type * from './types.js';\n","import type { ClientGlobals, ClientOptions, DirectusClient } from './types/client.js';\n\n/**\n * The default globals supplied to the client\n */\nconst defaultGlobals: ClientGlobals = {\n\tfetch: globalThis.fetch,\n\tWebSocket: globalThis.WebSocket,\n\tURL: globalThis.URL,\n};\n\n/**\n * Creates a client to communicate with a Directus app.\n *\n * @param url The URL to the Directus app.\n * @param config The optional configuration.\n *\n * @returns A Directus client.\n */\nexport const createDirectus = <Schema extends object = any>(\n\turl: string,\n\toptions: ClientOptions = {}\n): DirectusClient<Schema> => {\n\tconst globals = options.globals ? { ...defaultGlobals, ...options.globals } : defaultGlobals;\n\treturn {\n\t\tglobals,\n\t\turl: new globals.URL(url),\n\t\twith(createExtension) {\n\t\t\treturn {\n\t\t\t\t...this,\n\t\t\t\t...createExtension(this),\n\t\t\t};\n\t\t},\n\t};\n};\n","/**\n * Custom type guard to check if an object is likely a Fetch Response\n */\nexport function isFetchResponse(result: unknown): result is Response {\n\tif (typeof result !== 'object' || !result) return false;\n\n\treturn (\n\t\t'headers' in result &&\n\t\t'ok' in result &&\n\t\t'json' in result &&\n\t\ttypeof result.json === 'function' &&\n\t\t'text' in result &&\n\t\ttypeof result.json === 'function'\n\t);\n}\n","import { isFetchResponse } from './is-response.js';\n\n/**\n * Tries to extract a fetch response\n */\nexport async function extractData(response: unknown) {\n\tif (typeof response !== 'object' || !response) return;\n\n\tif (isFetchResponse(response)) {\n\t\tconst type = response.headers.get('Content-Type')?.toLowerCase();\n\n\t\tif (type?.startsWith('application/json') || type?.startsWith('application/health+json')) {\n\t\t\tconst result = await response.json();\n\t\t\tif (!response.ok) throw result;\n\t\t\tif ('data' in result) return result.data;\n\t\t\treturn result;\n\t\t}\n\n\t\tif (type?.startsWith('text/html') || type?.startsWith('text/plain')) {\n\t\t\tconst result = await response.text();\n\t\t\tif (!response.ok) throw result;\n\t\t\treturn result;\n\t\t}\n\n\t\t// fallback for anything else\n\t\treturn response;\n\t}\n\n\t// exception for alternatives like ofetch that don't return the Response object\n\treturn 'data' in response ? response.data : response;\n}\n","import type { FetchInterface } from '../index.js';\nimport { extractData } from './extract-data.js';\n\n/**\n * Request helper providing default settings\n *\n * @param url The request URL\n * @param options The request options\n *\n * @returns The API result if successful\n */\nexport const request = async <Output = any>(\n\turl: string,\n\toptions: RequestInit,\n\tfetcher: FetchInterface = globalThis.fetch\n): Promise<Output> => {\n\toptions.headers =\n\t\ttypeof options.headers === 'object' && !Array.isArray(options.headers)\n\t\t\t? (options.headers as Record<string, string>)\n\t\t\t: {};\n\n\tconst response = await fetcher(url, options);\n\n\treturn extractData(response).catch((reason) => {\n\t\tconst errors = typeof reason === 'object' && 'errors' in reason ? reason.errors : reason;\n\t\tthrow { errors, response };\n\t});\n};\n","import type { AggregationTypes, GroupByFields, Query } from '../../types/index.js';\n\ntype ExtendedQuery<Schema extends object, Item> = Query<Schema, Item> & {\n\taggregate?: Record<keyof AggregationTypes, string>;\n\tgroupBy?: (string | GroupByFields<Schema, Item>)[];\n};\n\n/**\n * Transform nested query object to an url compatible format\n *\n * @param query The nested query object\n *\n * @returns Flat query parameters\n */\nexport const queryToParams = <Schema extends object, Item>(\n\tquery: ExtendedQuery<Schema, Item>\n): Record<string, string> => {\n\tconst params: Record<string, string> = {};\n\n\tif (Array.isArray(query.fields) && query.fields.length > 0) {\n\t\ttype FieldItem = (typeof query.fields)[number];\n\n\t\tconst walkFields = (value: FieldItem, chain: string[] = []): string | string[] => {\n\t\t\tif (typeof value === 'object') {\n\t\t\t\tconst result = [];\n\n\t\t\t\tfor (const key in value) {\n\t\t\t\t\tconst nestedField = value[key as keyof typeof value] ?? [];\n\n\t\t\t\t\tif (Array.isArray(nestedField)) {\n\t\t\t\t\t\t// regular nested fields\n\t\t\t\t\t\tfor (const item of nestedField) {\n\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, key]));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof nestedField === 'object') {\n\t\t\t\t\t\t// many to any nested\n\t\t\t\t\t\tfor (const scope of Object.keys(nestedField)) {\n\t\t\t\t\t\t\tconst fields = (nestedField as Record<string, FieldItem[]>)[scope]!;\n\n\t\t\t\t\t\t\tfor (const item of fields) {\n\t\t\t\t\t\t\t\tresult.push(walkFields(item as FieldItem, [...chain, `${key}:${scope}`]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result.flatMap((items) => items);\n\t\t\t}\n\n\t\t\treturn [...chain, String(value)].join('.');\n\t\t};\n\n\t\tparams['fields'] = query.fields.flatMap((value) => walkFields(value)).join(',');\n\t}\n\n\tif (query.filter && Object.keys(query.filter).length > 0) {\n\t\tparams['filter'] = JSON.stringify(query.filter);\n\t}\n\n\tif (query.search) {\n\t\t// covers both empty string and undefined\n\t\tparams['search'] = query.search;\n\t}\n\n\tif ('sort' in query && query.sort) {\n\t\t// covers empty array and undefined\n\t\tparams['sort'] = typeof query.sort === 'string' ? query.sort : query.sort.join(',');\n\t}\n\n\tif (typeof query.limit === 'number' && query.limit >= -1) {\n\t\tparams['limit'] = String(query.limit);\n\t}\n\n\tif (typeof query.offset === 'number' && query.offset >= 0) {\n\t\tparams['offset'] = String(query.offset);\n\t}\n\n\tif (typeof query.page === 'number' && query.page >= 1) {\n\t\tparams['page'] = String(query.page);\n\t}\n\n\tif (query.deep && Object.keys(query.deep).length > 0) {\n\t\tparams['deep'] = JSON.stringify(query.deep);\n\t}\n\n\tif (query.alias && Object.keys(query.alias).length > 0) {\n\t\tparams['alias'] = JSON.stringify(query.alias);\n\t}\n\n\tif (query.aggregate && Object.keys(query.aggregate).length > 0) {\n\t\tparams['aggregate'] = JSON.stringify(query.aggregate);\n\t}\n\n\tif (query.groupBy && query.groupBy.length > 0) {\n\t\tparams['groupBy'] = query.groupBy.join(',');\n\t}\n\n\tfor (const [key, value] of Object.entries(query)) {\n\t\tif (key in params) continue;\n\n\t\tif (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n\t\t\tparams[key] = String(value);\n\t\t} else {\n\t\t\tparams[key] = JSON.stringify(value);\n\t\t}\n\t}\n\n\treturn params;\n};\n","import { queryToParams } from '../index.js';\n\nconst SEPARATOR = '/';\n\nconst mergePaths = (a: string, b: string) => {\n\tif (a.endsWith(SEPARATOR)) a = a.slice(0, -1);\n\tif (!b.startsWith(SEPARATOR)) b = SEPARATOR + b;\n\treturn a + b;\n};\n\n/**\n * Build URL based on provided options\n *\n * @param baseUrl The base URL\n * @param options The request options\n *\n * @returns URL\n */\nexport const getRequestUrl = (baseUrl: URL, path: string, params?: Record<string, any>): URL => {\n\tconst newPath = baseUrl.pathname === SEPARATOR ? path : mergePaths(baseUrl.pathname, path);\n\tconst url = new globalThis.URL(newPath, baseUrl);\n\n\tif (params) {\n\t\tfor (const [k, v] of Object.entries(queryToParams(params))) {\n\t\t\tif (v && typeof v === 'object' && !Array.isArray(v)) {\n\t\t\t\tfor (const [k2, v2] of Object.entries(v)) {\n\t\t\t\t\turl.searchParams.set(`${k}[${k2}]`, String(v2));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\turl.searchParams.set(k, v);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn url;\n};\n","import type { AuthenticationStorage, AuthenticationData } from '../types.js';\n\n/**\n * Simple memory storage implementation\n *\n * @returns AuthenticationStorage\n */\nexport const memoryStorage = () => {\n\tlet store: AuthenticationData | null = null;\n\n\treturn {\n\t\tget: async () => store,\n\t\tset: async (value: AuthenticationData | null) => {\n\t\t\tstore = value;\n\t\t},\n\t} as AuthenticationStorage;\n};\n","import type { LoginOptions } from '../index.js';\nimport type { DirectusClient } from '../types/client.js';\nimport { getRequestUrl } from '../utils/get-request-url.js';\nimport { request } from '../utils/request.js';\nimport type { AuthenticationClient, AuthenticationConfig, AuthenticationData, AuthenticationMode } from './types.js';\nimport { memoryStorage } from './utils/memory-storage.js';\n\nconst defaultConfigValues: AuthenticationConfig = {\n\tmsRefreshBeforeExpires: 30000, // 30 seconds\n\tautoRefresh: true,\n};\n\n/**\n * Creates a client to authenticate with Directus.\n *\n * @param mode AuthenticationMode\n * @param config The optional configuration.\n *\n * @returns A Directus authentication client.\n */\nexport const authentication = (mode: AuthenticationMode = 'cookie', config: Partial<AuthenticationConfig> = {}) => {\n\treturn <Schema extends object>(client: DirectusClient<Schema>): AuthenticationClient<Schema> => {\n\t\tconst authConfig = { ...defaultConfigValues, ...config };\n\t\tlet refreshPromise: Promise<AuthenticationData> | null = null;\n\t\tlet refreshTimeout: NodeJS.Timer | null = null;\n\t\tconst storage = authConfig.storage ?? memoryStorage();\n\n\t\tconst resetStorage = () => {\n\t\t\tstorage.set({ access_token: null, refresh_token: null, expires: null, expires_at: null });\n\t\t};\n\n\t\tconst activeRefresh = async () => {\n\t\t\ttry {\n\t\t\t\tawait refreshPromise;\n\t\t\t} finally {\n\t\t\t\trefreshPromise = null;\n\t\t\t}\n\t\t};\n\n\t\tconst refreshIfExpired = async () => {\n\t\t\tconst authData = await storage.get();\n\n\t\t\tif (refreshPromise || !authData?.expires_at) {\n\t\t\t\tawait activeRefresh();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (authData.expires_at < new Date().getTime() + authConfig.msRefreshBeforeExpires) {\n\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t/* throw err; */\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait activeRefresh();\n\t\t};\n\n\t\tconst setCredentials = (data: AuthenticationData) => {\n\t\t\tconst expires = data.expires ?? 0;\n\t\t\tdata.expires_at = new Date().getTime() + expires;\n\t\t\tstorage.set(data);\n\n\t\t\tif (authConfig.autoRefresh && expires > authConfig.msRefreshBeforeExpires && expires < Number.MAX_SAFE_INTEGER) {\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\n\t\t\t\trefreshTimeout = setTimeout(() => {\n\t\t\t\t\trefreshTimeout = null;\n\n\t\t\t\t\trefresh().catch((_err) => {\n\t\t\t\t\t\t/* throw err; */\n\t\t\t\t\t});\n\t\t\t\t}, expires - authConfig.msRefreshBeforeExpires);\n\t\t\t}\n\t\t};\n\n\t\tconst refresh = async () => {\n\t\t\tconst awaitRefresh = async () => {\n\t\t\t\tconst authData = await storage.get();\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tconst body: Record<string, any> = { mode };\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\tbody['refresh_token'] = authData.refresh_token;\n\t\t\t\t}\n\n\t\t\t\tfetchOptions.body = JSON.stringify(body);\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/refresh');\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t};\n\n\t\t\trefreshPromise = awaitRefresh().catch((err) => {\n\t\t\t\tthrow err;\n\t\t\t});\n\n\t\t\treturn refreshPromise;\n\t\t};\n\n\t\treturn {\n\t\t\trefresh,\n\t\t\tasync login(email: string, password: string, options: LoginOptions = {}) {\n\t\t\t\t// TODO: allow for websocket only authentication\n\t\t\t\tresetStorage();\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/login');\n\n\t\t\t\tconst authData: Record<string, string> = { email, password };\n\t\t\t\tif ('otp' in options) authData['otp'] = options.otp;\n\t\t\t\tauthData['mode'] = options.mode ?? mode;\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t\tbody: JSON.stringify(authData),\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tconst data = await request<AuthenticationData>(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tsetCredentials(data);\n\t\t\t\treturn data;\n\t\t\t},\n\t\t\tasync logout() {\n\t\t\t\tconst authData = await storage.get();\n\n\t\t\t\tconst fetchOptions: RequestInit = {\n\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t\t},\n\t\t\t\t};\n\n\t\t\t\tif ('credentials' in authConfig) {\n\t\t\t\t\tfetchOptions.credentials = authConfig.credentials;\n\t\t\t\t}\n\n\t\t\t\tif (mode === 'json' && authData?.refresh_token) {\n\t\t\t\t\tfetchOptions.body = JSON.stringify({\n\t\t\t\t\t\trefresh_token: authData.refresh_token,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst requestUrl = getRequestUrl(client.url, '/auth/logout');\n\t\t\t\tawait request(requestUrl.toString(), fetchOptions, client.globals.fetch);\n\n\t\t\t\tif (refreshTimeout) clearTimeout(refreshTimeout);\n\t\t\t\tresetStorage();\n\t\t\t},\n\t\t\tasync getToken() {\n\t\t\t\tawait refreshIfExpired();\n\n\t\t\t\tconst data = await storage.get();\n\t\t\t\treturn data?.access_token ?? null;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\tstorage.set({\n\t\t\t\t\taccess_token,\n\t\t\t\t\trefresh_token: null,\n\t\t\t\t\texpires: null,\n\t\t\t\t\texpires_at: null,\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t};\n};\n","import type { DirectusClient } from '../types/client.js';\nimport type { StaticTokenClient } from './types.js';\n\n/**\n * Creates a client to authenticate with Directus using a static token.\n *\n * @param token static token.\n *\n * @returns A Directus static token client.\n */\nexport const staticToken = (access_token: string) => {\n\treturn <Schema extends object>(_client: DirectusClient<Schema>): StaticTokenClient<Schema> => {\n\t\tlet token: string | null = access_token ?? null;\n\t\treturn {\n\t\t\tasync getToken() {\n\t\t\t\treturn token;\n\t\t\t},\n\t\t\tsetToken(access_token: string | null) {\n\t\t\t\ttoken = access_token;\n\t\t\t},\n\t\t};\n\t};\n};\n"],"mappings":"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","names":["auth_exports","__export","authentication","memoryStorage","staticToken","__toCommonJS","defaultGlobals","isFetchResponse","result","extractData","response","isFetchResponse","type","result","request","url","options","fetcher","response","extractData","reason","queryToParams","query","params","walkFields","value","chain","result","key","nestedField","item","scope","fields","items","SEPARATOR","mergePaths","a","b","getRequestUrl","baseUrl","path","params","newPath","url","k","v","queryToParams","k2","v2","memoryStorage","store","value","defaultConfigValues","authentication","mode","config","client","authConfig","refreshPromise","refreshTimeout","storage","memoryStorage","resetStorage","activeRefresh","refreshIfExpired","authData","refresh","_err","setCredentials","data","expires","fetchOptions","body","requestUrl","getRequestUrl","request","err","email","password","options","access_token","staticToken","access_token","_client","token"]}